{"modules": {"1": {"symbol": "MOD_ID_KERNEL", "module_name": "Kernel", "group_name": "System", "id": 0, "shifted_id": 0}, "2": {"symbol": "MOD_ID_DATAPOOL", "module_name": "DataPool", "group_name": "System", "id": 1, "shifted_id": 1024}, "3": {"symbol": "MOD_ID_FDIR", "module_name": "Fdir", "group_name": "System", "id": 2, "shifted_id": 2048}, "4": {"symbol": "MOD_ID_EVENTMANAGER", "module_name": "EventManager", "group_name": "System", "id": 3, "shifted_id": 3072}, "5": {"symbol": "MOD_ID_MEMSTOREMANAGER", "module_name": "MemStoreManager", "group_name": "System", "id": 4, "shifted_id": 4096}, "6": {"symbol": "MOD_ID_PARAMMONITOR", "module_name": "ParamMonitor", "group_name": "System", "id": 5, "shifted_id": 5120}, "7": {"symbol": "MOD_ID_SCHEDULER", "module_name": "Scheduler", "group_name": "System", "id": 6, "shifted_id": 6144}, "8": {"symbol": "MOD_ID_SERVINTERFACE", "module_name": "ServInterface", "group_name": "System", "id": 7, "shifted_id": 7168}, "9": {"symbol": "MOD_ID_TCPROCESSOR", "module_name": "TcProcessor", "group_name": "System", "id": 8, "shifted_id": 8192}, "10": {"symbol": "MOD_ID_BOARD", "module_name": "Board", "group_name": "Drivers", "id": 16, "shifted_id": 16384}, "11": {"symbol": "MOD_ID_DELAY", "module_name": "Delay", "group_name": "Drivers", "id": 17, "shifted_id": 17408}, "12": {"symbol": "MOD_ID_EEPROM", "module_name": "Eeprom", "group_name": "Drivers", "id": 18, "shifted_id": 18432}, "13": {"symbol": "MOD_ID_GPIO", "module_name": "Gpio", "group_name": "Drivers", "id": 19, "shifted_id": 19456}, "14": {"symbol": "MOD_ID_I2C", "module_name": "I2c", "group_name": "Drivers", "id": 20, "shifted_id": 20480}, "15": {"symbol": "MOD_ID_RTC", "module_name": "Rtc", "group_name": "Drivers", "id": 21, "shifted_id": 21504}, "16": {"symbol": "MOD_ID_SPI", "module_name": "Spi", "group_name": "Drivers", "id": 22, "shifted_id": 22528}, "17": {"symbol": "MOD_ID_TIMER", "module_name": "Timer", "group_name": "Drivers", "id": 23, "shifted_id": 23552}, "18": {"symbol": "MOD_ID_UART", "module_name": "Uart", "group_name": "Drivers", "id": 24, "shifted_id": 24576}, "19": {"symbol": "MOD_ID_WDT", "module_name": "Wdt", "group_name": "Drivers", "id": 25, "shifted_id": 25600}, "20": {"symbol": "MOD_ID_ANTENNA", "module_name": "Antenna", "group_name": "Components", "id": 32, "shifted_id": 32768}, "21": {"symbol": "MOD_ID_CAMERA", "module_name": "Camera", "group_name": "Components", "id": 33, "shifted_id": 33792}, "22": {"symbol": "MOD_ID_EPS", "module_name": "Eps", "group_name": "Components", "id": 34, "shifted_id": 34816}, "23": {"symbol": "MOD_ID_FRAM", "module_name": "Fram", "group_name": "Components", "id": 35, "shifted_id": 35840}, "24": {"symbol": "MOD_ID_GNSS", "module_name": "Gnss", "group_name": "Components", "id": 36, "shifted_id": 36864}, "25": {"symbol": "MOD_ID_IMU", "module_name": "Imu", "group_name": "Components", "id": 37, "shifted_id": 37888}, "26": {"symbol": "MOD_ID_LED", "module_name": "Led", "group_name": "Components", "id": 38, "shifted_id": 38912}, "27": {"symbol": "MOD_ID_RADIO", "module_name": "Radio", "group_name": "Components", "id": 39, "shifted_id": 39936}, "28": {"symbol": "MOD_ID_TEMP", "module_name": "Temp", "group_name": "Components", "id": 40, "shifted_id": 40960}, "29": {"symbol": "MOD_ID_BEACONAPP", "module_name": "BeaconApp", "group_name": "Applications", "id": 48, "shifted_id": 49152}, "30": {"symbol": "MOD_ID_CAMERAAPP", "module_name": "CameraApp", "group_name": "Applications", "id": 49, "shifted_id": 50176}, "31": {"symbol": "MOD_ID_DEPLOYMENTAPP", "module_name": "DeploymentApp", "group_name": "Applications", "id": 50, "shifted_id": 51200}, "32": {"symbol": "MOD_ID_PAYLOADAPP", "module_name": "PayloadApp", "group_name": "Applications", "id": 51, "shifted_id": 52224}, "33": {"symbol": "MOD_ID_SYSTEMHEALTHAPP", "module_name": "SystemHealthApp", "group_name": "Applications", "id": 52, "shifted_id": 53248}}, "errors": {"1": {"symbol": "IMU_ERROR_NOT_INITIALISED", "module": "Imu", "description": "Attempted to use the IMU when it wasn't initialised. *", "value": 37889}, "2": {"symbol": "IMU_ERROR_NEW_NONE_COMMAND", "module": "Imu", "description": "Attempted to issue an IMU_CMD_NONE to the IMU module.", "value": 37890}, "3": {"symbol": "IMU_ERROR_EVENTMANAGER_ERROR", "module": "Imu", "description": "There was an error in the EventManager that is preventing the IMU component operating.", "value": 37891}, "4": {"symbol": "IMU_ERROR_INVALID_STATE", "module": "Imu", "description": "Invalid DP.IMU.STATE value.", "value": 37892}, "5": {"symbol": "IMU_ERROR_INVALID_SUBSTATE", "module": "Imu", "description": "Invalid DP.IMU.SUBSTATE value.", "value": 37893}, "6": {"symbol": "IMU_ERROR_UNRECOGNISED_CMD", "module": "Imu", "description": "Unrecognised DP.IMU.COMMAND value. *", "value": 37894}, "7": {"symbol": "IMU_ERROR_CANNOT_ISSUE_NEW_COMMAND", "module": "Imu", "description": "Cannot issue a new command to the IMU since the IMU is not in the WAIT_NEW_COMMAND state. It could either not be initialised or is still finishing another command", "value": 37895}, "8": {"symbol": "IMU_ERROR_I2C_ERROR", "module": "Imu", "description": "There was an error in the I2C driver.  See the corresponding value of DP.IMU.I2C_ERROR for the root cause.", "value": 37896}, "9": {"symbol": "IMU_ERROR_INVALID_I2C_ACTION_STATUS", "module": "Imu", "description": "Unexpected value of an I2c_ActionStatus return.", "value": 37897}, "10": {"symbol": "EVENTMANAGER_ERROR_MAX_EVENTS_REACHED", "module": "EventManager", "description": "The maximum number of events has been reached and no more events will be raised until an event is polled.", "value": 3073}, "11": {"symbol": "EVENTMANAGER_ERROR_OUT_OF_MEMORY", "module": "EventManager", "description": "There was insufficient memory to increase the size of the event  lists.", "value": 3074}, "12": {"symbol": "EVENTMANAGER_ERROR_SHRINK_REALLOC_FAILED", "module": "EventManager", "description": "A call to realloc() failed while trying to shrink the lists. This indicates memory corruption.", "value": 3075}, "13": {"symbol": "EVENTMANAGER_ERROR_NOT_INITIALISED", "module": "EventManager", "description": "An EventManager function was called when the EventManager wasn't initialised. Make sure to call EventManager_init() before using the EventManager.", "value": 3076}, "14": {"symbol": "EEPROM_ERROR_INIT_RECOVERY_FAILED", "module": "Eeprom", "description": "Error indicating that recovery action required by the EEPROM initialisation failed.  From the Tivaware user manual section 9.2.3.8 if this error occurs in a stable power state this is an indicator that the EEPROM has exceeded its lifetime of write/erases. If the supply voltage is unstable when this error occurs the operation may still succeed once the voltage is stabilised.", "value": 18433}, "15": {"symbol": "EEPROM_ERROR_PERIP_NOT_READY", "module": "Eeprom", "description": "Indicates that the maximum number of wait attempts on the EEPROM peripheral being enabled has been exceeded.", "value": 18434}, "16": {"symbol": "EEPROM_ERROR_UNEXPECTED_SIZE", "module": "Eeprom", "description": "The EEPROM self test failed because the size returned by the Tivaware function EEPROMSizeGet() and the expected size EEPROM_SIZE_BYTES differ.", "value": 18435}, "17": {"symbol": "EEPROM_ERROR_BUSY", "module": "Eeprom", "description": "The EEPROM status is either EEPROM_RC_WORKING or EEPROM_RC_WRBUSY, meaning that a write operation cannot be done until the EEPROM is no longer busy.", "value": 18436}, "18": {"symbol": "EEPROM_ERROR_NO_PERMISSIONS", "module": "Eeprom", "description": "A write operation cannot succeed because the user has no permission to write to the address (EEPROM_RC_NOPERM).", "value": 18437}, "19": {"symbol": "EEPROM_ERROR_WRITE_TOO_LARGE", "module": "Eeprom", "description": "An EEPROM write failed because the combintion of address and length would exceed the size of the EEPROM.", "value": 18438}, "20": {"symbol": "EEPROM_ERROR_READ_TOO_LARGE", "module": "Eeprom", "description": "An EEPROM read failed because the combintion of address and length would exceed the size of the EEPROM.", "value": 18439}, "21": {"symbol": "I2C_ERROR_NOT_INITIALISED", "module": "I2c", "description": "The I2C driver has not been initialised.", "value": 20481}, "22": {"symbol": "I2C_ERROR_I2C_PERIPH_ENABLE_FAILED", "module": "I2c", "description": "Failed to enable an I2C peripheral.", "value": 20482}, "23": {"symbol": "I2C_ERROR_GPIO_PERIPH_ENABLE_FAILED", "module": "I2c", "description": "Failed to enable a GPIO peripheral. *", "value": 20483}, "24": {"symbol": "I2C_ERROR_NO_ACTION_FOR_DEVICE", "module": "I2c", "description": "Indicates that no action has been queued for the given device", "value": 20484}, "25": {"symbol": "I2C_ERROR_CHECK_ON_NONE_ACTION", "module": "I2c", "description": "Attempted to check the TivaWare error status of an action which is of type NONE.", "value": 20485}, "26": {"symbol": "I2C_ERROR_GET_RECVED_BYTES_FROM_SEND", "module": "I2c", "description": "Error indicating that a user attempted to read recieved bytes from a device that had sent data.", "value": 20486}, "27": {"symbol": "I2C_ERROR_GET_RECVED_BYTES_ON_NON_SUCCESS_ACTION", "module": "I2c", "description": "Attempted to get the recieved bytes from a non successful action. Use I2c_get_device_action_status to check that the action was successful before calling I2c_get_device_recved_bytes.", "value": 20487}, "28": {"symbol": "I2C_ERROR_ZERO_LENGTH_SEND", "module": "I2c", "description": "Attempted to send 0 bytes.", "value": 20488}, "29": {"symbol": "I2C_ERROR_MEMORY_ALLOC_FOR_SEND_FAILED", "module": "I2c", "description": "Failed to allocate memory for send action.", "value": 20489}, "30": {"symbol": "I2C_ERROR_MEMORY_ALLOC_FOR_RECV_FAILED", "module": "I2c", "description": "Failed to allocate memory for recieve action.", "value": 20490}, "31": {"symbol": "I2C_ERROR_MAX_ACTIONS_REACHED", "module": "I2c", "description": "A new action could not be queued as the maximum number of actions has been reached.", "value": 20491}, "32": {"symbol": "I2C_ERROR_ZERO_LENGTH_RECEIVE", "module": "I2c", "description": "A new action could not be queued as the maximum number of actions has been reached.", "value": 20492}, "33": {"symbol": "I2C_ERROR_UNEXPECTED_ACTION_STEP", "module": "I2c", "description": "An unexpected action step index was found while executing an action.", "value": 20493}, "34": {"symbol": "I2C_ERROR_UNEXPECTED_ACTION_SUBSTEP", "module": "I2c", "description": "An unexpected action step index was found while executing an action.", "value": 20494}, "35": {"symbol": "I2C_ERROR_MODULE_MASTER_BUSY", "module": "I2c", "description": "A master I2C module is busy.", "value": 20495}, "36": {"symbol": "I2C_ERROR_ADDRESS_ACK_FAILED", "module": "I2c", "description": "Failed to acknowledge the address of an I2C device, is the device address correct?", "value": 20496}, "37": {"symbol": "I2C_ERROR_DATA_ACK_FAILED", "module": "I2c", "description": "Failed to acknowledge data sent to the master. The slave could be unresponsive.", "value": 20497}, "38": {"symbol": "I2C_ERROR_ARBITRATION_LOST", "module": "I2c", "description": "The arbitration of the bus has been lost. This could indicate that a slave is in error.", "value": 20498}, "39": {"symbol": "I2C_ERROR_UNKNOWN_TIVAWARE_ERROR", "module": "I2c", "description": "An unkown TivaWare library error has occured", "value": 20499}, "40": {"symbol": "I2C_ERROR_EVENTMANAGER_ERROR", "module": "I2c", "description": "Error in the event manager.", "value": 20500}, "41": {"symbol": "I2C_ERROR_MODULE_LOCKED_BY_ANOTHER_DEVICE", "module": "I2c", "description": "The action cannot be queued as the module (bus) the device is on is already locked by another device.", "value": 20501}}, "events": {"1": {"symbol": "EVT_IMU_NEW_COMMAND", "module": "Imu", "description": "New command event.  This event is raised when a new command is issued by a user to the Imu module. It is used to identify when a new command is available to be executed. The user should not raise this event themselves, instead use the Imu_new_command() function.", "value": 37889}, "2": {"symbol": "EVT_IMU_READ_GYRO_SUCCESS", "module": "Imu", "description": "IMU gyroscope read command completed successfully.", "value": 37890}, "3": {"symbol": "EVT_IMU_READ_GYRO_FAILURE", "module": "Imu", "description": "IMU gyroscope read command failed.", "value": 37891}, "4": {"symbol": "EVT_IMU_READ_MAGNE_SUCCESS", "module": "Imu", "description": "IMU magnetometer read command completed successfully.", "value": 37892}, "5": {"symbol": "EVT_IMU_READ_MAGNE_FAILURE", "module": "Imu", "description": "IMU magnetometer read command failed.", "value": 37893}, "6": {"symbol": "EVT_IMU_READ_TEMP_SUCCESS", "module": "Imu", "description": "IMU temeprature read command completed successfully.", "value": 37894}, "7": {"symbol": "EVT_IMU_READ_TEMP_FAILURE", "module": "Imu", "description": "IMU temperature read command failed.", "value": 37895}, "8": {"symbol": "EVT_IMU_STATE_CHANGE", "module": "Imu", "description": "Event used to signal a state change in the IMU. This is done so that the new state will run it's first function in the next cycle without the system going to sleep.", "value": 37898}, "9": {"symbol": "EVT_IMU_INIT_SUCCESS", "module": "Imu", "description": "IMU initialisation successful event.", "value": 37899}, "10": {"symbol": "EVT_IMU_INIT_FAILURE", "module": "Imu", "description": "IMU initialisation failed event.", "value": 37900}, "11": {"symbol": "EVT_EVENTMANAGER_ERROR", "module": "EventManager", "description": "Event associated with an event manager error.  This event indicates that an error has occured in the EventManager, and the corresponding error code in the EventManager's DataPool DP.EVENTMANAGER.ERROR_CODE has been set.  Note, if the error arises from already being at the maximum number of events the error code will be set and the corresponding DP.EVENTMANAGER.MAX_EVENTS_REACHED flag will be raised. This event will not be raised.", "value": 3073}, "12": {"symbol": "EVT_I2C_NEW_ACTION", "module": "I2c", "description": "This event indicates that a new action has been requested for the I2C driver to execute.", "value": 20481}, "13": {"symbol": "EVT_I2C_ACTION_FINISHED", "module": "I2c", "description": "Event that indicates when an I2C action has been finished. The user must use I2c_get_device_action_status for their device to determine whether or not their action has finished, or if it was another action.  This event __shall not__ be polled by the user, instead EventManager_is_event_raised must be used. The I2c module will clear the event when all finished actions have been handled.", "value": 20482}}}
